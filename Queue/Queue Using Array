/**
--------------------------------------------------------------------
âœ… Problem: Implement Circular Queue

Design a circular queue that supports the following operations:
- `enqueue(x)` â†’ Insert an element at the rear of the queue.
- `dequeue()`  â†’ Remove the front element of the queue.
- `getFront()` â†’ Get the front element.
- `getRear()`  â†’ Get the rear element.
- `isEmpty()`  â†’ Check if the queue is empty.
- `isFull()`   â†’ Check if the queue is full.

--------------------------------------------------------------------
Example:
Input:
myQueue q(5);
q.enqueue(10);
q.enqueue(20);
q.enqueue(30);
cout << q.getFront() << endl; // 10
q.dequeue();
cout << q.getFront() << endl; // 20

Output:
10
20

--------------------------------------------------------------------
âœ… Approach: Circular Queue using Array

ðŸ’¡ **Idea:**
To efficiently utilize space, use a **circular array** instead of shifting elements.

We maintain:
- `front` â†’ Index of the front element  
- `rear`  â†’ Index of the last inserted element  
- `count` â†’ Current number of elements  
- `capacity` â†’ Total size of the queue  

When inserting (`enqueue`) or removing (`dequeue`),  
use **modular arithmetic** to wrap around the array:
rear = (rear + 1) % capacity;
front = (front + 1) % capacity;


--------------------------------------------------------------------
âœ… Implementation:
*/

#include <bits/stdc++.h>
using namespace std;

class myQueue {
public:
    vector<int> arr;   // Array for storing queue elements
    int capacity;      // Maximum size of queue
    int rear;          // Index for rear element
    int front;         // Index for front element
    int count;         // Current number of elements

    // Constructor to initialize queue
    myQueue(int n) {
        capacity = n;
        rear = -1;
        front = -1;
        count = 0;
        arr.resize(n);
    }

    // Check if queue is empty
    bool isEmpty() {
        return (count == 0);
    }

    // Check if queue is full
    bool isFull() {
        return (count == capacity);
    }

    // Enqueue operation (Insert at rear)
    void enqueue(int x) {
        if (isFull()) return;

        if (isEmpty()) {
            front = 0; // first element
        }

        rear = (rear + 1) % capacity; // move circularly
        arr[rear] = x;
        count++;
    }

    // Dequeue operation (Remove from front)
    void dequeue() {
        if (isEmpty()) return;

        front = (front + 1) % capacity;
        count--;

        // Reset when queue becomes empty
        if (count == 0) {
            front = -1;
            rear = -1;
        }
    }

    // Get front element
    int getFront() {
        if (isEmpty()) return -1;
        return arr[front];
    }

    // Get rear element
    int getRear() {
        if (isEmpty()) return -1;
        return arr[rear];
    }
};

/**
--------------------------------------------------------------------
âœ… Dry Run Example:

Queue capacity = 5

Operations:
enqueue(10) â†’ front=0, rear=0, arr=[10]
enqueue(20) â†’ front=0, rear=1, arr=[10,20]
enqueue(30) â†’ front=0, rear=2, arr=[10,20,30]
getFront() â†’ 10
dequeue()  â†’ front moves to 1 â†’ arr=[10,20,30], front=1
getFront() â†’ 20
enqueue(40) â†’ rear=3
enqueue(50) â†’ rear=4
enqueue(60) â†’ wraps around â†’ rear=(4+1)%5=0, arr[0]=60

Circular Effect â†’ rear wraps to index 0!

--------------------------------------------------------------------
âœ… Time Complexity:
- enqueue(): O(1)
- dequeue(): O(1)
- getFront()/getRear(): O(1)
- isEmpty()/isFull(): O(1)

âœ… Space Complexity:
O(n) â†’ for the array

âœ… Concept Used:
- Circular Array (using modulo arithmetic)
- Queue Fundamentals (FIFO)

âœ… Edge Cases:
- Enqueue when full â†’ ignored
- Dequeue when empty â†’ ignored
- Single element removal â†’ resets queue pointers

--------------------------------------------------------------------
*/

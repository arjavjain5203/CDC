/**
--------------------------------------------------------------------
‚úÖ Problem: Implement Queue using Stacks

Design a queue using **two stacks** `s1` and `s2`.

You must implement the following operations:
- `push(x)` ‚Üí Pushes element `x` to the back of the queue.
- `pop()` ‚Üí Removes and returns the element from the front of the queue.
- `peek()` ‚Üí Returns the element at the front of the queue.
- `empty()` ‚Üí Returns true if the queue is empty, false otherwise.

--------------------------------------------------------------------
Example:
Input:
MyQueue q;
q.push(1);
q.push(2);
cout << q.peek();  // Output: 1
cout << q.pop();   // Output: 1
cout << q.empty(); // Output: false

--------------------------------------------------------------------
‚úÖ Approach: Two Stack Method

üí° **Idea:**
Use two stacks:
- `s1`: for enqueue (push)
- `s2`: for dequeue (pop/peek)

When popping or peeking:
1Ô∏è‚É£ If `s2` is empty ‚Üí transfer all elements from `s1` to `s2`.  
   (This reverses order, making front accessible at the top of `s2`.)
2Ô∏è‚É£ Then pop/peek from `s2`.

--------------------------------------------------------------------
‚úÖ Implementation:
*/

#include <stack>
using namespace std;

class MyQueue {
public:
    stack<int> s1;  // Input stack (for push operations)
    stack<int> s2;  // Output stack (for pop/peek operations)

    MyQueue() {}

    // Push element x to the back of queue
    void push(int x) {
        s1.push(x);
    }

    // Removes the element from in front of queue and returns it
    int pop() {
        if (s2.empty()) {
            // Transfer all elements from s1 ‚Üí s2
            while (!s1.empty()) {
                s2.push(s1.top());
                s1.pop();
            }
        }

        int topVal = s2.top();
        s2.pop();
        return topVal;
    }

    // Get the front element without removing it
    int peek() {
        if (s2.empty()) {
            // Transfer all elements from s1 ‚Üí s2
            while (!s1.empty()) {
                s2.push(s1.top());
                s1.pop();
            }
        }

        if (s2.empty()) return -1; // Queue is empty
        return s2.top();
    }

    // Returns true if queue is empty
    bool empty() {
        return s1.empty() && s2.empty();
    }
};

/**
--------------------------------------------------------------------
‚úÖ Dry Run Example:

Operations:
push(1) ‚Üí s1 = [1], s2 = []
push(2) ‚Üí s1 = [1,2], s2 = []
peek()  ‚Üí s2 empty ‚Üí move s1 ‚Üí s2 = [2,1] ‚Üí peek = 1
pop()   ‚Üí remove top of s2 (1) ‚Üí s2 = [2]
empty() ‚Üí s1 empty? no, s2 empty? no ‚Üí false

Output:
1 1 false

--------------------------------------------------------------------
‚úÖ Time Complexity:
- push(): O(1)
- pop(): Amortized O(1)
- peek(): Amortized O(1)
- empty(): O(1)

‚è± *Amortized O(1)* because each element is moved from `s1` to `s2` only once.

‚úÖ Space Complexity:
O(n) ‚Äî storing all elements in the two stacks.

‚úÖ Concept Used:
- Stack reversal to simulate queue order (FIFO)
- Lazy transfer (move only when needed)

‚úÖ Edge Cases:
- Queue empty during pop/peek ‚Üí handle gracefully.
- Multiple consecutive pushes before pop ‚Üí works fine.

--------------------------------------------------------------------
*/

/**
--------------------------------------------------------------------
✅ Problem: Sum of Left Leaves (LeetCode 404)

You are given the root of a binary tree.
Your task is to return the **sum of all left leaf nodes**.

A *left leaf* is a node that:
  - is the **left child** of its parent, AND
  - has **no children** (both left and right are null)

--------------------------------------------------------------------
✅ Approach: Recursive DFS (Depth-First Search)

1️⃣ Base case:
   - If the current node is null → return 0.

2️⃣ Recursive case:
   - If the current node has a left child:
        - Check if it’s a **leaf node** (no left/right children)
          → If yes, add its value to the sum.
   - Recursively compute for:
        - The left subtree
        - The right subtree

--------------------------------------------------------------------
✅ Implementation:
*/

class Solution {
public:
    int sumOfLeftLeaves(TreeNode* root) {
        if (!root) return 0;  // Base case: empty tree

        int sum = 0;

        // If there is a left child, check if it's a leaf
        if (root->left) {
            if (root->left->left == nullptr && root->left->right == nullptr)
                sum += root->left->val; // Add left leaf value
        }

        // Recurse on both subtrees
        sum += sumOfLeftLeaves(root->left);
        sum += sumOfLeftLeaves(root->right);

        return sum;
    }
};

/**
--------------------------------------------------------------------
✅ Dry Run Example:

Input Tree:
       3
      / \
     9  20
       /  \
      15   7

Left leaves: 9 (left of 3) and 15 (left of 20)
Output: 9 + 15 = 24

--------------------------------------------------------------------
✅ Time Complexity:
O(n) — each node is visited once.

✅ Space Complexity:
O(h) — recursion stack (where h is the tree height).

✅ Concepts Used:
- Binary Tree
- Depth-First Search (DFS)
- Recursion
--------------------------------------------------------------------
*/

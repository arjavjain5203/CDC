/*
ğŸ”¹ Approach (Binary Search):

We use a classic binary search technique to find the target element in a sorted array.

1. Initialize two pointers:
   - i = 0  (start index)
   - j = nums.size() - 1  (end index)

2. Use a loop while i <= j:
   - Calculate mid correctly to avoid integer overflow:
         mid = i + (j - i) / 2

   - If nums[mid] == target â†’ return mid
   - If nums[mid] > target â†’ search in the left half (j = mid - 1)
   - Otherwise â†’ search in the right half (i = mid + 1)

3. If the loop ends without finding target â†’ return -1.

âœ… Corrected Mid Formula:
Your code uses:
    mid = i - (i - j) / 2  âŒ (This is incorrect and can cause wrong indexing)
Fixed version:
    mid = i + (j - i) / 2 âœ…

ğŸ”¹ Time Complexity:
O(log n)  
(Binary search always divides the search space in half)

ğŸ”¹ Space Complexity:
O(1)  
(No extra memory used)

âœ… Example:
nums = [-1, 0, 3, 5, 9, 12], target = 9  
mid = 3 â†’ nums[3] = 5 < 9 â†’ search right  
mid = 4 â†’ nums[4] = 9 â†’ found â†’ return 4
*/

class Solution {
public:
    int search(vector<int>& nums, int target) {
        int i = 0;
        int j = nums.size() - 1;

        while (i <= j) {
            // âœ… Correct mid calculation
            int mid = i + (j - i) / 2;

            if (nums[mid] == target)
                return mid;
            else if (nums[mid] > target)
                j = mid - 1;
            else
                i = mid + 1;
        }
        return -1;
    }
};

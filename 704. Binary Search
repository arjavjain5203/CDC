/*
🔹 Approach (Binary Search):

We use a classic binary search technique to find the target element in a sorted array.

1. Initialize two pointers:
   - i = 0  (start index)
   - j = nums.size() - 1  (end index)

2. Use a loop while i <= j:
   - Calculate mid correctly to avoid integer overflow:
         mid = i + (j - i) / 2

   - If nums[mid] == target → return mid
   - If nums[mid] > target → search in the left half (j = mid - 1)
   - Otherwise → search in the right half (i = mid + 1)

3. If the loop ends without finding target → return -1.

✅ Corrected Mid Formula:
Your code uses:
    mid = i - (i - j) / 2  ❌ (This is incorrect and can cause wrong indexing)
Fixed version:
    mid = i + (j - i) / 2 ✅

🔹 Time Complexity:
O(log n)  
(Binary search always divides the search space in half)

🔹 Space Complexity:
O(1)  
(No extra memory used)

✅ Example:
nums = [-1, 0, 3, 5, 9, 12], target = 9  
mid = 3 → nums[3] = 5 < 9 → search right  
mid = 4 → nums[4] = 9 → found → return 4
*/

class Solution {
public:
    int search(vector<int>& nums, int target) {
        int i = 0;
        int j = nums.size() - 1;

        while (i <= j) {
            // ✅ Correct mid calculation
            int mid = i + (j - i) / 2;

            if (nums[mid] == target)
                return mid;
            else if (nums[mid] > target)
                j = mid - 1;
            else
                i = mid + 1;
        }
        return -1;
    }
};

/**
--------------------------------------------------------------------
‚úÖ Problem: Binary Tree Preorder Traversal (LeetCode #144)

Given the root of a binary tree, return the **preorder traversal** of its nodes' values.

üß© Preorder Traversal Order:
‚Üí Visit Root  
‚Üí Traverse Left Subtree  
‚Üí Traverse Right Subtree

--------------------------------------------------------------------
Example:
Input:
    1
     \
      2
     /
    3

Output: [1, 2, 3]

Explanation:
- Visit 1 (root)
- Go right ‚Üí 2
- Go left of 2 ‚Üí 3

--------------------------------------------------------------------
‚úÖ Approach: Recursive DFS (Preorder)

üí° **Idea:**
Use recursion to traverse:
1Ô∏è‚É£ Visit the current node (add value to `ans`).  
2Ô∏è‚É£ Recursively visit the left subtree.  
3Ô∏è‚É£ Recursively visit the right subtree.

--------------------------------------------------------------------
‚úÖ Implementation:
*/

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    // Helper function for recursive traversal
    void helper(TreeNode* root, vector<int>& ans) {
        if (root == NULL) return;

        ans.push_back(root->val);      // Step 1: Visit root
        helper(root->left, ans);       // Step 2: Traverse left
        helper(root->right, ans);      // Step 3: Traverse right
    }

    // Main function
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> ans;
        helper(root, ans);
        return ans;
    }
};

/**
--------------------------------------------------------------------
‚úÖ Dry Run Example:

Input Tree:
      1
       \
        2
       /
      3

Call Stack:
helper(1) ‚Üí ans = [1]
 ‚Üí helper(2) ‚Üí ans = [1, 2]
   ‚Üí helper(3) ‚Üí ans = [1, 2, 3]

Output ‚Üí [1, 2, 3]

--------------------------------------------------------------------
‚úÖ Time Complexity:
O(N) ‚Äî each node is visited once

‚úÖ Space Complexity:
O(H) ‚Äî recursion stack, where H = height of the tree  
(in worst case H = N for a skewed tree)

‚úÖ Concept Used:
- Depth First Search (DFS)
- Preorder Traversal (Root ‚Üí Left ‚Üí Right)

--------------------------------------------------------------------
*/

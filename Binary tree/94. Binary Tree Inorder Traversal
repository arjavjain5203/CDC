/**
--------------------------------------------------------------------
‚úÖ Problem: Binary Tree Inorder Traversal (LeetCode #94)

Given the root of a binary tree, return the **inorder traversal** of its nodes' values.

üß© Inorder Traversal Order:
‚Üí Traverse Left Subtree  
‚Üí Visit Root  
‚Üí Traverse Right Subtree

--------------------------------------------------------------------
Example:
Input:
    1
     \
      2
     /
    3

Output: [1, 3, 2]

Explanation:
- Go left of 1 ‚Üí None  
- Visit 1  
- Go right ‚Üí 2  
  - Go left ‚Üí 3  
  - Visit 3  
  - Visit 2  

--------------------------------------------------------------------
‚úÖ Approach: Recursive DFS (Inorder)

üí° **Idea:**
Use recursion to traverse the tree in **Left ‚Üí Root ‚Üí Right** order:
1Ô∏è‚É£ Recursively call left subtree.  
2Ô∏è‚É£ Add current node value.  
3Ô∏è‚É£ Recursively call right subtree.

--------------------------------------------------------------------
‚úÖ Implementation:
*/

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
     
    // Helper function for recursive inorder traversal
    void helper(TreeNode* root, vector<int> &ans)
    {
        if (root == NULL)
            return;

        helper(root->left, ans);    // Step 1: Traverse left subtree
        ans.push_back(root->val);   // Step 2: Visit root
        helper(root->right, ans);   // Step 3: Traverse right subtree
    }

    // Main function
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> ans;
        helper(root, ans);
        return ans;
    }
};

/**
--------------------------------------------------------------------
‚úÖ Dry Run Example:

Input Tree:
      1
       \
        2
       /
      3

Call Sequence:
helper(1)
 ‚Üí helper(2)
   ‚Üí helper(3)
   ‚Üí ans = [3]
 ‚Üí ans = [3, 2]
ans = [1, 3, 2]

Output ‚Üí [1, 3, 2]

--------------------------------------------------------------------
‚úÖ Time Complexity:
O(N) ‚Äî each node is visited exactly once

‚úÖ Space Complexity:
O(H) ‚Äî recursion stack, where H = height of the tree  
(in worst case, H = N for a skewed tree)

‚úÖ Concept Used:
- Depth First Search (DFS)
- Inorder Traversal (Left ‚Üí Root ‚Üí Right)

--------------------------------------------------------------------
*/

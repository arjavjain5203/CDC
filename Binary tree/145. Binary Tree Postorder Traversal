/**
--------------------------------------------------------------------
‚úÖ Problem: Binary Tree Postorder Traversal (LeetCode #145)

Given the root of a binary tree, return the **postorder traversal** of its nodes' values.

üß© Postorder Traversal Order:
‚Üí Traverse Left Subtree  
‚Üí Traverse Right Subtree  
‚Üí Visit Root Node

--------------------------------------------------------------------
Example:
Input:
    1
     \
      2
     /
    3

Output: [3, 2, 1]

Explanation:
- Go left of 1 ‚Üí None  
- Go right ‚Üí 2  
  - Go left ‚Üí 3  
  - Visit 3  
  - Visit 2  
- Visit 1  

--------------------------------------------------------------------
‚úÖ Approach: Recursive DFS (Postorder)

üí° **Idea:**
Use recursion to traverse the tree in **Left ‚Üí Right ‚Üí Root** order:
1Ô∏è‚É£ Recursively call left subtree.  
2Ô∏è‚É£ Recursively call right subtree.  
3Ô∏è‚É£ Add current node value.

--------------------------------------------------------------------
‚úÖ Implementation:
*/

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:

    // Helper function for recursive postorder traversal
    void helper(TreeNode* root, vector<int> &ans)
    {
        if (root == NULL)
            return;

        helper(root->left, ans);   // Step 1: Traverse left subtree
        helper(root->right, ans);  // Step 2: Traverse right subtree
        ans.push_back(root->val);  // Step 3: Visit root node
    }

    // Main function
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> ans;
        helper(root, ans);
        return ans;
    }
};

/**
--------------------------------------------------------------------
‚úÖ Dry Run Example:

Input Tree:
      1
       \
        2
       /
      3

Call Sequence:
helper(1)
 ‚Üí helper(2)
   ‚Üí helper(3)
     ‚Üí ans = [3]
   ‚Üí ans = [3, 2]
 ‚Üí ans = [3, 2, 1]

Output ‚Üí [3, 2, 1]

--------------------------------------------------------------------
‚úÖ Time Complexity:
O(N) ‚Äî each node is visited exactly once

‚úÖ Space Complexity:
O(H) ‚Äî recursion stack, where H = height of the tree  
(in worst case, H = N for a skewed tree)

‚úÖ Concept Used:
- Depth First Search (DFS)
- Postorder Traversal (Left ‚Üí Right ‚Üí Root)

--------------------------------------------------------------------
*/

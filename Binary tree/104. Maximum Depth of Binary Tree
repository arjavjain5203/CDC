/**
--------------------------------------------------------------------
âœ… Problem: Maximum Depth of Binary Tree (LeetCode #104)

Given the root of a binary tree, return its maximum depth.

The maximum depth is the number of nodes along the longest path  
from the root node down to the farthest leaf node.

--------------------------------------------------------------------
Example:

Input:
      3
     / \
    9  20
       / \
      15  7

Output: 3

Explanation:
- Path 1: 3 â†’ 9 â†’ (null) â†’ depth 2
- Path 2: 3 â†’ 20 â†’ 15 â†’ depth 3
â†’ Maximum depth = 3

--------------------------------------------------------------------
âœ… Approach: Recursive Depth-First Search (DFS)

ðŸ’¡ **Idea:**
The depth of a tree = 1 + max(depth of left subtree, depth of right subtree)

Base case:  
If the current node is `NULL`, the depth is 0.

--------------------------------------------------------------------
âœ… Implementation:
*/

class Solution {
public:
    int maxDepth(TreeNode* root) {
        // Base case: empty tree
        if (root == NULL)
            return 0;

        // Recursively calculate depth of left and right subtrees
        int leftDepth  = maxDepth(root->left);
        int rightDepth = maxDepth(root->right);

        // Current node adds +1 to the depth
        return 1 + max(leftDepth, rightDepth);
    }
};

/**
--------------------------------------------------------------------
âœ… Dry Run Example:

Input:
      3
     / \
    9  20
       / \
      15  7

Recursion steps:
maxDepth(3)
= 1 + max(maxDepth(9), maxDepth(20))
= 1 + max(1, 2)
= 3

--------------------------------------------------------------------
âœ… Time Complexity:
O(N) â€” Each node is visited once.

âœ… Space Complexity:
O(H) â€” Call stack height (H = height of the tree, worst O(N) for skewed tree).

âœ… Concepts Used:
- Recursion
- Depth-First Search (DFS)
--------------------------------------------------------------------
*/

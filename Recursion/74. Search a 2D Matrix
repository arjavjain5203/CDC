/*
-----------------------------------------------------------------
✅ Problem:
Search for a target element in a 2D matrix where each row is sorted 
in ascending order, and the first element of each row is greater 
than the last element of the previous row.

✅ Approach:
We follow a **two-step process**:
1️⃣ Identify the potential row in which the target could exist:
   - Traverse rows until `matrix[i][0] > target`.
   - The previous row (`i-1`) will contain the target (if present).

2️⃣ Perform **Binary Search** on that identified row:
   - Use standard binary search between start and end indices.
   - Compare middle element with the target.

✅ Edge Cases:
- Empty matrix or empty row → return false
- Target smaller than the first element → return false
- Target not found in any row → return false

✅ Time Complexity:
- Finding potential row → O(m)
- Binary Search in that row → O(log n)
✅ Total: O(m + log n)

✅ Space Complexity: O(1)
No extra space used besides a few variables.

✅ Notes:
- Efficient for moderately sized matrices.
- Avoids converting the matrix into a 1D view.

✅ No main() function included (as per your instruction).
-----------------------------------------------------------------
*/

class Solution {
public:
   
    // Helper function to perform binary search on a given row
    bool binarysearch(vector<vector<int>>& matrix, int target, int r, int start, int stop) {
        while (start <= stop) {
            int mid = start + (stop - start) / 2;

            if (matrix[r][mid] == target)
                return true;
            else if (matrix[r][mid] > target)
                stop = mid - 1;
            else
                start = mid + 1;
        }
        return false;
    }

    // Main function to search the target in the matrix
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        if (matrix.empty() || matrix[0].empty())
            return false;

        // Early rejection if target is smaller than the first element
        if (matrix[0][0] > target)
            return false;

        int row = matrix.size() - 1;

        // Step 1: Find the potential row
        for (int i = 0; i < matrix.size(); i++) {
            if (matrix[i][0] > target) {
                row = i - 1;
                break;
            }
        }

        if (row < 0)
            return false;

        // Step 2: Perform binary search on the identified row
        return binarysearch(matrix, target, row, 0, matrix[0].size() - 1);
    }
};




// MOST OPTIMIZED Approach


/*
-----------------------------------------------------------------
✅ Problem:
Search for a target element in a 2D matrix where:
- Each row is sorted in ascending order.
- The first element of each row is greater than the last element of the previous row.

✅ Optimized Approach (Flattened Binary Search):
1️⃣ Treat the 2D matrix as a **virtual 1D sorted array**.
   - Index mapping:
       row = mid / number_of_columns
       col = mid % number_of_columns
2️⃣ Apply standard binary search on the flattened index space [0 ... (m*n - 1)].
3️⃣ Access matrix elements using the above mapping to compare with the target.

✅ Why This is Optimal:
- It performs a **single binary search** across the entire matrix.
- Time complexity is logarithmic in total elements (O(log(m*n))).
- Avoids row-wise traversal.

✅ Time Complexity: O(log(m * n))
   → Single binary search over all elements.

✅ Space Complexity: O(1)
   → Constant extra space, as all work is done in-place.

✅ Edge Cases:
- Empty matrix or empty row.
- Target smaller than smallest or larger than largest element.
- Target not found in any position.

✅ Notes:
- More efficient than row-by-row search (O(m + log n)).
- Ideal for large sorted matrices.

✅ No main() function included (as per your repo standards).
-----------------------------------------------------------------
*/

class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        // Edge case: empty matrix
        if (matrix.empty() || matrix[0].empty())
            return false;

        int rows = matrix.size();
        int cols = matrix[0].size();
        int start = 0;
        int end = rows * cols - 1;

        // Binary search on the "virtual 1D" array
        while (start <= end) {
            int mid = start + (end - start) / 2;
            int row = mid / cols;
            int col = mid % cols;
            int element = matrix[row][col];

            if (element == target)
                return true;
            else if (element < target)
                start = mid + 1;
            else
                end = mid - 1;
        }

        return false;
    }
};

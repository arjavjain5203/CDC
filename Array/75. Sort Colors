/**
--------------------------------------------------------------------
âœ… Problem: Sort Colors (Dutch National Flag Problem)

You are given an array `nums` containing `n` objects colored red, white, or blue,  
where:
- 0 â†’ red  
- 1 â†’ white  
- 2 â†’ blue  

Sort the array **in-place** so that objects of the same color are adjacent,  
with the colors in the order **red â†’ white â†’ blue**.

--------------------------------------------------------------------
Example:
Input:  nums = [2, 0, 2, 1, 1, 0]  
Output: [0, 0, 1, 1, 2, 2]

Explanation:
All 0s (red) come first, followed by 1s (white), then 2s (blue).

--------------------------------------------------------------------
âœ… Approach: Dutch National Flag Algorithm (Three Pointers)

ğŸ’¡ **Idea:**
We maintain three regions in the array using pointers:
- `i` â†’ boundary for 0s (start of array)
- `j` â†’ current element being checked
- `k` â†’ boundary for 2s (end of array)

We iterate through the array and rearrange elements based on their value:
1ï¸âƒ£ If `nums[j] == 0` â†’ swap with `nums[i]`, then increment both `i` and `j`.  
2ï¸âƒ£ If `nums[j] == 2` â†’ swap with `nums[k]`, then decrement `k`.  
3ï¸âƒ£ If `nums[j] == 1` â†’ just move `j` forward.

--------------------------------------------------------------------
âœ… Implementation:
*/

#include <vector>
#include <algorithm>
using namespace std;

class Solution {
public:
    void sortColors(vector<int>& nums) {
        int n = nums.size();
        int i = 0;        // boundary for 0s
        int j = 0;        // current pointer
        int k = n - 1;    // boundary for 2s

        while (j <= k) {
            if (nums[j] == 0) {
                swap(nums[j], nums[i]);
                i++;
                j++;
            } 
            else if (nums[j] == 2) {
                swap(nums[j], nums[k]);
                k--;
            } 
            else { // nums[j] == 1
                j++;
            }
        }
    }
};

/**
--------------------------------------------------------------------
âœ… Dry Run Example:

Input: nums = [2, 0, 2, 1, 1, 0]

Initial: i=0, j=0, k=5 â†’ [2, 0, 2, 1, 1, 0]  
Step 1: nums[j]=2 â†’ swap(j,k) â†’ [0, 0, 2, 1, 1, 2], k=4  
Step 2: nums[j]=0 â†’ swap(i,j) â†’ [0, 0, 2, 1, 1, 2], i=1, j=1  
Step 3: nums[j]=0 â†’ swap(i,j) â†’ [0, 0, 2, 1, 1, 2], i=2, j=2  
Step 4: nums[j]=2 â†’ swap(j,k) â†’ [0, 0, 1, 1, 2, 2], k=3  
Step 5: nums[j]=1 â†’ j++ â†’ [0, 0, 1, 1, 2, 2]  

Final Output â†’ [0, 0, 1, 1, 2, 2]

--------------------------------------------------------------------
âœ… Time Complexity:
O(n) â€” Each element is visited at most once.

âœ… Space Complexity:
O(1) â€” Sorting done in-place.

âœ… Concept Used:
- Three-pointer technique
- In-place partitioning

âœ… Edge Cases:
- All same elements (e.g., [1,1,1])
- Already sorted input
- Reverse sorted input

--------------------------------------------------------------------
*/

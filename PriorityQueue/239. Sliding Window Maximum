/**
--------------------------------------------------------------------
✅ Problem: Sliding Window Maximum (LeetCode 239)

You are given an array `nums` and an integer `k`.
Your task is to return an array of the **maximums** of all contiguous
subarrays of size `k`.

--------------------------------------------------------------------
✅ Approach: Monotonic Deque

We use a **deque (double-ended queue)** to keep track of indices 
of useful elements in the current window, maintaining these properties:

1️⃣ The deque always stores **indices** of elements in **decreasing order of their values**.  
   → `nums[q.front()]` is the maximum of the current window.

2️⃣ Remove indices that:
   - Are **out of the window range** (`i - k`)
   - Correspond to elements **smaller** than the current one (`nums[q.back()] < nums[i]`)

3️⃣ After processing each element:
   - If we’ve processed at least `k` elements, record the current maximum.

--------------------------------------------------------------------
✅ Implementation:
*/

class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        vector<int> res;          // stores result (maximum of each window)
        deque<int> q;             // stores indices of useful elements

        for (int i = 0; i < nums.size(); i++) {

            // Step 1️⃣: Remove indices out of current window
            if (!q.empty() && q.front() <= i - k)
                q.pop_front();

            // Step 2️⃣: Maintain decreasing order of values in deque
            while (!q.empty() && nums[q.back()] < nums[i])
                q.pop_back();

            // Step 3️⃣: Add current index
            q.push_back(i);

            // Step 4️⃣: Record the maximum (front of deque) once window size ≥ k
            if (i >= k - 1)
                res.push_back(nums[q.front()]);
        }

        return res;
    }
};

/**
--------------------------------------------------------------------
✅ Dry Run Example:

Input:
nums = [1,3,-1,-3,5,3,6,7], k = 3

Sliding Windows and Max:
[1,3,-1] → 3  
[3,-1,-3] → 3  
[-1,-3,5] → 5  
[-3,5,3] → 5  
[5,3,6] → 6  
[3,6,7] → 7  

✅ Output: [3,3,5,5,6,7]

--------------------------------------------------------------------
✅ Time Complexity:
O(n) — each element is pushed and popped from the deque at most once.

✅ Space Complexity:
O(k) — deque stores at most k indices.

✅ Concepts Used:
- Sliding Window
- Monotonic Deque
- Greedy Optimization
--------------------------------------------------------------------
*/

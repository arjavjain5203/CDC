/**
--------------------------------------------------------------------
âœ… Problem: Lower Bound (Binary Search)

Given a **sorted array** `arr[]` and an integer `target`,  
find the **index of the first element** in `arr` that is **greater than or equal to `target`**.

If all elements are smaller than `target`, return `n` (the array size).  
If all elements are greater than `target`, return `0`.

--------------------------------------------------------------------
Example:
Input:
arr = [1, 2, 4, 4, 5, 6]
target = 4

Output: 2

Explanation:
- The first element â‰¥ 4 is `arr[2] = 4`.
--------------------------------------------------------------------
âœ… Approach: Binary Search

ğŸ’¡ **Idea:**
Use binary search to find the **smallest index** `i` such that:
arr[i] >= target

ğŸ“˜ Algorithm:
1ï¸âƒ£ Initialize `start = 0`, `end = n - 1`.  
2ï¸âƒ£ While `start < end`:
   - Find `mid = start + (end - start) / 2`
   - If `arr[mid] < target`, search **right half** â†’ `start = mid + 1`
   - Else, search **left half** â†’ `end = mid`
3ï¸âƒ£ When loop ends, `end` will be the **first position â‰¥ target**.

--------------------------------------------------------------------
âœ… Implementation:
*/

#include <vector>
using namespace std;

class Solution {
public:
    int lowerBound(vector<int>& arr, int target) {
        // Handle boundary conditions
        if (arr[arr.size() - 1] < target) return arr.size();  // all smaller
        if (arr[0] >= target) return 0;                       // all larger or equal

        int start = 0, end = arr.size() - 1;

        while (start < end) {
            int mid = start + (end - start) / 2;

            if (arr[mid] < target)
                start = mid + 1;   // move right
            else
                end = mid;         // move left
        }

        return end;
    }
};

/**
--------------------------------------------------------------------
âœ… Dry Run Example:

arr = [1, 2, 4, 4, 5, 6], target = 4

start = 0, end = 5
mid = 2 â†’ arr[2] = 4 â†’ end = 2
start = 0, end = 2
mid = 1 â†’ arr[1] = 2 < 4 â†’ start = 2
âœ… start == end == 2 â†’ return 2

--------------------------------------------------------------------
âœ… Time Complexity: O(log n)
âœ… Space Complexity: O(1)

âœ… Concept Used:
- Binary Search (modified)
- Edge case handling for boundaries

âœ… Edge Cases:
- target smaller than all â†’ return 0
- target larger than all â†’ return n
- duplicates â†’ returns first occurrence of â‰¥ target

--------------------------------------------------------------------
*/

/**
--------------------------------------------------------------------
✅ Problem: Asteroid Collision

We are given an array `asteroids` of integers representing asteroids moving in space.

- Each asteroid moves at the **same speed**.
- The **sign** of each integer represents its **direction**:
  - Positive → moving **right**
  - Negative → moving **left**

When two asteroids collide:
- The **smaller one** (by absolute value) explodes.
- If they are **equal**, both explode.
- Asteroids moving in the **same direction never collide**.

Return the state of the asteroids after all collisions.

--------------------------------------------------------------------
Example 1:
Input:  asteroids = [5, 10, -5]
Output: [5, 10]

Explanation:
10 and -5 collide → |10| > |−5| → −5 explodes → final: [5, 10]

--------------------------------------------------------------------
Example 2:
Input:  asteroids = [8, -8]
Output: []

Explanation:
Both have equal size → both explode.

--------------------------------------------------------------------
✅ Approach: Stack Simulation (Collision Resolution)

💡 **Idea:**
Use a stack to simulate asteroid movement:
1️⃣ Traverse each asteroid `curr`.
2️⃣ If `curr` is moving **right** or stack top is moving **left**, just push it.
3️⃣ If `curr` is moving **left** and stack top is moving **right**, a collision happens:
   - If `|curr| > |top|` → top explodes (pop stack).
   - If `|curr| == |top|` → both explode (pop stack and skip push).
   - If `|curr| < |top|` → current asteroid explodes (do not push).

--------------------------------------------------------------------
✅ Implementation:
*/

#include <vector>
#include <cmath>
using namespace std;

class Solution {
public:
    vector<int> asteroidCollision(vector<int>& asteroids) {
        vector<int> stack;  // Used to simulate the asteroid field

        for (int i = 0; i < asteroids.size(); i++) {
            int curr = asteroids[i];
            bool collision = false;

            // Check for potential collisions (right-moving top vs left-moving current)
            while (!stack.empty() && curr < 0 && stack.back() > 0) {
                if (abs(stack.back()) < abs(curr)) {
                    // Top asteroid explodes, continue checking
                    stack.pop_back();
                } 
                else if (abs(stack.back()) == abs(curr)) {
                    // Both explode
                    stack.pop_back();
                    collision = true;
                    break;
                } 
                else {
                    // Current asteroid explodes
                    collision = true;
                    break;
                }
            }

            // If current asteroid survived all collisions
            if (!collision) {
                stack.push_back(curr);
            }
        }

        return stack;  // Remaining asteroids after all collisions
    }
};

/**
--------------------------------------------------------------------
✅ Dry Run Example:

Input: asteroids = [10, 2, -5]

Step-by-step:
stack = []

1️⃣ curr = 10 → stack empty → push → [10]
2️⃣ curr = 2 → same direction → push → [10, 2]
3️⃣ curr = -5 → collision with 2 → |2| < |5| → pop 2 → [10]
                 again collision with 10 → |10| > |5| → current (-5) explodes

Final → [10]

Output → [10]

--------------------------------------------------------------------
✅ Time Complexity:
O(n)  
→ Each asteroid is pushed and popped at most once.

✅ Space Complexity:
O(n)  
→ Stack stores the surviving asteroids.

✅ Concepts Used:
- Stack simulation
- Sign-based direction detection
- Collision handling using absolute values

✅ Edge Cases:
- All moving in same direction → No collision.
- Equal and opposite → Both explode.
- Chain reactions (e.g., [10, 2, -5]) handled properly.

--------------------------------------------------------------------
*/

/**
--------------------------------------------------------------------
âœ… Problem: Asteroid Collision

We are given an array `asteroids` of integers representing asteroids moving in space.

- Each asteroid moves at the **same speed**.
- The **sign** of each integer represents its **direction**:
  - Positive â†’ moving **right**
  - Negative â†’ moving **left**

When two asteroids collide:
- The **smaller one** (by absolute value) explodes.
- If they are **equal**, both explode.
- Asteroids moving in the **same direction never collide**.

Return the state of the asteroids after all collisions.

--------------------------------------------------------------------
Example 1:
Input:  asteroids = [5, 10, -5]
Output: [5, 10]

Explanation:
10 and -5 collide â†’ |10| > |âˆ’5| â†’ âˆ’5 explodes â†’ final: [5, 10]

--------------------------------------------------------------------
Example 2:
Input:  asteroids = [8, -8]
Output: []

Explanation:
Both have equal size â†’ both explode.

--------------------------------------------------------------------
âœ… Approach: Stack Simulation (Collision Resolution)

ðŸ’¡ **Idea:**
Use a stack to simulate asteroid movement:
1ï¸âƒ£ Traverse each asteroid `curr`.
2ï¸âƒ£ If `curr` is moving **right** or stack top is moving **left**, just push it.
3ï¸âƒ£ If `curr` is moving **left** and stack top is moving **right**, a collision happens:
   - If `|curr| > |top|` â†’ top explodes (pop stack).
   - If `|curr| == |top|` â†’ both explode (pop stack and skip push).
   - If `|curr| < |top|` â†’ current asteroid explodes (do not push).

--------------------------------------------------------------------
âœ… Implementation:
*/

#include <vector>
#include <cmath>
using namespace std;

class Solution {
public:
    vector<int> asteroidCollision(vector<int>& asteroids) {
        vector<int> stack;  // Used to simulate the asteroid field

        for (int i = 0; i < asteroids.size(); i++) {
            int curr = asteroids[i];
            bool collision = false;

            // Check for potential collisions (right-moving top vs left-moving current)
            while (!stack.empty() && curr < 0 && stack.back() > 0) {
                if (abs(stack.back()) < abs(curr)) {
                    // Top asteroid explodes, continue checking
                    stack.pop_back();
                } 
                else if (abs(stack.back()) == abs(curr)) {
                    // Both explode
                    stack.pop_back();
                    collision = true;
                    break;
                } 
                else {
                    // Current asteroid explodes
                    collision = true;
                    break;
                }
            }

            // If current asteroid survived all collisions
            if (!collision) {
                stack.push_back(curr);
            }
        }

        return stack;  // Remaining asteroids after all collisions
    }
};

/**
--------------------------------------------------------------------
âœ… Dry Run Example:

Input: asteroids = [10, 2, -5]

Step-by-step:
stack = []

1ï¸âƒ£ curr = 10 â†’ stack empty â†’ push â†’ [10]
2ï¸âƒ£ curr = 2 â†’ same direction â†’ push â†’ [10, 2]
3ï¸âƒ£ curr = -5 â†’ collision with 2 â†’ |2| < |5| â†’ pop 2 â†’ [10]
                 again collision with 10 â†’ |10| > |5| â†’ current (-5) explodes

Final â†’ [10]

Output â†’ [10]

--------------------------------------------------------------------
âœ… Time Complexity:
O(n)  
â†’ Each asteroid is pushed and popped at most once.

âœ… Space Complexity:
O(n)  
â†’ Stack stores the surviving asteroids.

âœ… Concepts Used:
- Stack simulation
- Sign-based direction detection
- Collision handling using absolute values

âœ… Edge Cases:
- All moving in same direction â†’ No collision.
- Equal and opposite â†’ Both explode.
- Chain reactions (e.g., [10, 2, -5]) handled properly.

--------------------------------------------------------------------
*/

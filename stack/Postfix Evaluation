/**
--------------------------------------------------------------------
‚úÖ Problem: Evaluate Postfix Expression

Given a postfix (Reverse Polish Notation) expression represented as  
a vector of strings `arr[]`, evaluate the expression and return the result.  

Each element of `arr` is either:
- An **operand** (integer)
- An **operator** (`+`, `-`, `*`, `/`, `^`)

--------------------------------------------------------------------
Example:
Input:  arr = {"2", "1", "+", "3", "*"}
Output: 9

Explanation:
Postfix expression ‚Üí (2 + 1) * 3 = 9

--------------------------------------------------------------------
‚úÖ Approach: Stack-Based Evaluation

üí° **Idea:**
Use a stack to store operands.  
For each token:
1Ô∏è‚É£ If it is a **number**, push it onto the stack.  
2Ô∏è‚É£ If it is an **operator**, pop the top two elements ‚Üí apply the operator ‚Üí push result back.

At the end, the stack will contain only one element ‚Üí the final result.

--------------------------------------------------------------------
‚úÖ Implementation:
*/

#include <vector>
#include <string>
#include <stack>
#include <cmath>
using namespace std;

class Solution {
public:
    int evaluatePostfix(vector<string>& arr) {
        stack<int> st;  // Stack to store operands

        for (string& token : arr) {
            // Check if current token is an operator
            if (token == "+" || token == "-" || token == "*" || token == "/" || token == "^") {
                int b = st.top(); st.pop();   // Operand 2
                int a = st.top(); st.pop();   // Operand 1
                int result;

                if (token == "+") result = a + b;
                else if (token == "-") result = a - b;
                else if (token == "*") result = a * b;
                else if (token == "/") {
                    // Handle floor division for negative numbers
                    if (a * b < 0 && a % b != 0)
                        result = a / b - 1;
                    else
                        result = a / b;
                }
                else if (token == "^") result = pow(a, b);

                st.push(result);  // Push result back to stack
            } 
            else {
                // It's a number ‚Üí convert string to integer
                st.push(stoi(token));
            }
        }

        return st.top();  // Final result
    }
};

/**
--------------------------------------------------------------------
‚úÖ Dry Run Example:

Input: arr = {"2", "1", "+", "3", "*"}

Iteration:
1Ô∏è‚É£ Push 2 ‚Üí stack = [2]
2Ô∏è‚É£ Push 1 ‚Üí stack = [2, 1]
3Ô∏è‚É£ Operator '+' ‚Üí Pop 1,2 ‚Üí 2+1=3 ‚Üí Push 3 ‚Üí stack = [3]
4Ô∏è‚É£ Push 3 ‚Üí stack = [3, 3]
5Ô∏è‚É£ Operator '*' ‚Üí Pop 3,3 ‚Üí 3*3=9 ‚Üí Push 9 ‚Üí stack = [9]

Output ‚Üí 9

--------------------------------------------------------------------
‚úÖ Time Complexity:
O(n)  
‚Üí Each element is pushed and popped at most once.

‚úÖ Space Complexity:
O(n)  
‚Üí Stack used to store operands during evaluation.

‚úÖ Concept Used:
- Stack (LIFO structure)
- Postfix Expression Evaluation
- Handling integer division correctly for negative numbers.

‚úÖ Edge Cases:
- Single operand (e.g., {"5"}) ‚Üí Output = 5  
- Mixed negative and positive numbers  
- Division involving negatives (e.g., {"10", "-3", "/"})  
- Large exponents handled using `pow()`

--------------------------------------------------------------------
*/

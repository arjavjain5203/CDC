/**
--------------------------------------------------------------------
âœ… Problem: Min Stack

Design a stack that supports the following operations in **O(1)** time:
1ï¸âƒ£ push(x) â†’ Push element x onto stack  
2ï¸âƒ£ pop()   â†’ Removes the element on top of the stack  
3ï¸âƒ£ top()   â†’ Get the top element  
4ï¸âƒ£ getMin() â†’ Retrieve the minimum element in the stack  

Example:
Input:
["MinStack","push","push","push","getMin","pop","top","getMin"]
[[],[-2],[0],[-3],[],[],[],[]]

Output:
[null,null,null,null,-3,null,0,-2]

Explanation:
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   // return -3
minStack.pop();
minStack.top();      // return 0
minStack.getMin();   // return -2
--------------------------------------------------------------------
âœ… Approach: Stack of Pairs

ğŸ‘‰ We maintain a stack that stores **pairs**: `{value, current_min}`.

When pushing a value:
- If the stack is empty â†’ `{val, val}`
- Else â†’ `{val, min(val, top().second)}`

This ensures every stack frame â€œremembersâ€ the minimum so far.

When popping:
- Simply pop the top element.

When getting min:
- Return `top().second` since it stores the minimum up to that point.

--------------------------------------------------------------------
âœ… Implementation:
*/

class MinStack {
public:
    vector<pair<int, int>> s;

    MinStack() {
        // Constructor initializes an empty stack
    }

    void push(int val) {
        if (s.empty())
            s.push_back({val, val});
        else
            s.push_back({val, min(s.back().second, val)});
    }

    void pop() {
        s.pop_back();
    }

    int top() {
        return s.back().first;
    }

    int getMin() {
        return s.back().second;
    }
};

/**
--------------------------------------------------------------------
âœ… Dry Run Example:

Operations:
push(5) â†’ stack = [(5, 5)]
push(3) â†’ stack = [(5, 5), (3, 3)]
push(7) â†’ stack = [(5, 5), (3, 3), (7, 3)]
push(2) â†’ stack = [(5, 5), (3, 3), (7, 3), (2, 2)]
getMin() â†’ 2
pop() â†’ stack = [(5, 5), (3, 3), (7, 3)]
getMin() â†’ 3
top() â†’ 7

--------------------------------------------------------------------
âœ… Time Complexity:
- push() â†’ O(1)
- pop()  â†’ O(1)
- top()  â†’ O(1)
- getMin() â†’ O(1)

âœ… Space Complexity:
- O(n) â€” Each push stores both value and current minimum.

âœ… Concepts Used:
- Stack (LIFO)
- Pair tracking of min value

âœ… Alternate Approaches:
- Use two separate stacks: one for values, one for minimums.
  (More readable, but uses extra structure.)

--------------------------------------------------------------------
*/

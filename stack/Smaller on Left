/**
--------------------------------------------------------------------
âœ… Problem: Smallest on Left

Given an array `arr[]` of size `n`,  
for each element `arr[i]`, find the **largest element on its left** which is **smaller than arr[i]**.  
If no such element exists, output `-1` for that position.

Example:
Input:  arr = [2, 5, 3, 7, 8, 1, 9]
Output: [-1, 2, 2, 5, 7, -1, 8]

Explanation:
- For 2 â†’ No left element â†’ -1  
- For 5 â†’ Smallest smaller on left = 2  
- For 3 â†’ Smaller on left = 2  
- For 7 â†’ Smaller on left = 5  
- For 8 â†’ Smaller on left = 7  
- For 1 â†’ None smaller on left â†’ -1  
- For 9 â†’ Smaller on left = 8  

--------------------------------------------------------------------
âœ… Approach: Ordered Set + Lower Bound

ğŸ’¡ **Idea:**
Maintain a **balanced BST (set)** of all previously seen elements (on the left).  
For each element `arr[i]`:
1ï¸âƒ£ Use `s.lower_bound(arr[i])` to find the **first element â‰¥ arr[i]**.  
2ï¸âƒ£ The element just before that iterator (if exists) will be the **largest smaller** element.
3ï¸âƒ£ Insert `arr[i]` into the set for future elements.

--------------------------------------------------------------------
âœ… Implementation:
*/

vector<int> Smallestonleft(int arr[], int n) {
    set<int> s;             // Stores processed elements in sorted order
    vector<int> ans;        // Result vector

    for (int i = 0; i < n; i++) {
        auto temp = s.lower_bound(arr[i]);  // First element >= arr[i]

        if (temp == s.begin()) {
            ans.push_back(-1);  // No smaller element found
        } 
        else {
            temp--;              // Move one step left to get smaller element
            ans.push_back(*temp);
        }

        s.insert(arr[i]);        // Add current element for future checks
    }

    return ans;
}

/**
--------------------------------------------------------------------
âœ… Dry Run Example:

Input: arr = [2, 5, 3, 7, 8, 1, 9]

Iteration:
i=0 â†’ s={} â†’ -1 â†’ s={2}  
i=1 â†’ s={2} â†’ lower_bound(5)=end â†’ *prev(end)=2 â†’ s={2,5}  
i=2 â†’ s={2,5} â†’ lower_bound(3)=5 â†’ *prev(5)=2 â†’ s={2,3,5}  
i=3 â†’ s={2,3,5} â†’ lower_bound(7)=end â†’ *prev(end)=5 â†’ s={2,3,5,7}  
i=4 â†’ s={2,3,5,7} â†’ lower_bound(8)=end â†’ *prev(end)=7 â†’ s={2,3,5,7,8}  
i=5 â†’ s={2,3,5,7,8} â†’ lower_bound(1)=2 â†’ begin â†’ -1 â†’ s={1,2,3,5,7,8}  
i=6 â†’ s={1,2,3,5,7,8} â†’ lower_bound(9)=end â†’ *prev(end)=8 â†’ s={1,2,3,5,7,8,9}

Output â†’ [-1, 2, 2, 5, 7, -1, 8]

--------------------------------------------------------------------
âœ… Time Complexity:
O(n * log n)  
â†’ Each insertion and lower_bound in `set` takes O(log n)

âœ… Space Complexity:
O(n) for storing previous elements in the set.

âœ… Concept Used:
- STL `set` (Self-balancing BST)
- `lower_bound()` for finding first â‰¥ element efficiently

âœ… Edge Cases:
- All elements increasing â†’ Output = previous element each time.
- All elements decreasing â†’ Output = -1 for all.
- Duplicate elements â†’ Works fine since `set` handles unique values.

--------------------------------------------------------------------
*/

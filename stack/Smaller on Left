/**
--------------------------------------------------------------------
✅ Problem: Smallest on Left

Given an array `arr[]` of size `n`,  
for each element `arr[i]`, find the **largest element on its left** which is **smaller than arr[i]**.  
If no such element exists, output `-1` for that position.

Example:
Input:  arr = [2, 5, 3, 7, 8, 1, 9]
Output: [-1, 2, 2, 5, 7, -1, 8]

Explanation:
- For 2 → No left element → -1  
- For 5 → Smallest smaller on left = 2  
- For 3 → Smaller on left = 2  
- For 7 → Smaller on left = 5  
- For 8 → Smaller on left = 7  
- For 1 → None smaller on left → -1  
- For 9 → Smaller on left = 8  

--------------------------------------------------------------------
✅ Approach: Ordered Set + Lower Bound

💡 **Idea:**
Maintain a **balanced BST (set)** of all previously seen elements (on the left).  
For each element `arr[i]`:
1️⃣ Use `s.lower_bound(arr[i])` to find the **first element ≥ arr[i]**.  
2️⃣ The element just before that iterator (if exists) will be the **largest smaller** element.
3️⃣ Insert `arr[i]` into the set for future elements.

--------------------------------------------------------------------
✅ Implementation:
*/

vector<int> Smallestonleft(int arr[], int n) {
    set<int> s;             // Stores processed elements in sorted order
    vector<int> ans;        // Result vector

    for (int i = 0; i < n; i++) {
        auto temp = s.lower_bound(arr[i]);  // First element >= arr[i]

        if (temp == s.begin()) {
            ans.push_back(-1);  // No smaller element found
        } 
        else {
            temp--;              // Move one step left to get smaller element
            ans.push_back(*temp);
        }

        s.insert(arr[i]);        // Add current element for future checks
    }

    return ans;
}

/**
--------------------------------------------------------------------
✅ Dry Run Example:

Input: arr = [2, 5, 3, 7, 8, 1, 9]

Iteration:
i=0 → s={} → -1 → s={2}  
i=1 → s={2} → lower_bound(5)=end → *prev(end)=2 → s={2,5}  
i=2 → s={2,5} → lower_bound(3)=5 → *prev(5)=2 → s={2,3,5}  
i=3 → s={2,3,5} → lower_bound(7)=end → *prev(end)=5 → s={2,3,5,7}  
i=4 → s={2,3,5,7} → lower_bound(8)=end → *prev(end)=7 → s={2,3,5,7,8}  
i=5 → s={2,3,5,7,8} → lower_bound(1)=2 → begin → -1 → s={1,2,3,5,7,8}  
i=6 → s={1,2,3,5,7,8} → lower_bound(9)=end → *prev(end)=8 → s={1,2,3,5,7,8,9}

Output → [-1, 2, 2, 5, 7, -1, 8]

--------------------------------------------------------------------
✅ Time Complexity:
O(n * log n)  
→ Each insertion and lower_bound in `set` takes O(log n)

✅ Space Complexity:
O(n) for storing previous elements in the set.

✅ Concept Used:
- STL `set` (Self-balancing BST)
- `lower_bound()` for finding first ≥ element efficiently

✅ Edge Cases:
- All elements increasing → Output = previous element each time.
- All elements decreasing → Output = -1 for all.
- Duplicate elements → Works fine since `set` handles unique values.

--------------------------------------------------------------------
*/
